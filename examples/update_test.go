package examples

import (
	"fmt"
	"testing"

	"github.com/lukeoleson/go-pg-playground/data/dal"
	"github.com/stretchr/testify/assert"

	"github.com/lukeoleson/go-pg-playground/data/models"
)

func Test_UpdateMultipleRowsByNonPrimaryKey_Problem(t *testing.T) {
	db := dal.Connect()
	defer db.Close()

	////////////////////////////////////////////////
	// 1. Set the data you want updated into a slice

	testRowIds := []int{3, 4, 136, 179}
	// NOTE: There are 3 eds and 1 jennifer in the test db
	currentFirstNames := []string{"ED", "JENNIFER"}
	newFirstNames := []string{"ANNA", "JOE", "PRINCE", "RALF"}
	actors := []models.Actor{
		{
			FirstName: newFirstNames[0],
		},
		{
			FirstName: newFirstNames[1],
		},
		{
			FirstName: newFirstNames[2],
		},
		{
			FirstName: newFirstNames[3],
		},
	}

	////////////////////////////////////////////////////
	// 2. Perform an update with a non-primary key value

	// It *looks* like this query will update all the "ED" and "JENNIFER" rows
	// to the names we entered in `actors` above...
	_, err := db.Model(&actors).
		Column("first_name").
		WhereIn("a.first_name IN (?)", currentFirstNames).
		Returning("*").
		Update()
	if err != nil {
		fmt.Println(err)
	}

	// Assertions
	// Get the latest data from the DB...
	var selectedActors []models.Actor
	err = db.Model(&selectedActors).WhereIn("actor_id IN (?)", testRowIds).Select()
	assert.NoError(t, err)
	// ... check that the correct number of rows were updated...
	assert.Equal(t, len(testRowIds), len(selectedActors))

	// ... but note that each row was updated with the first name of the first element from `actors`.
	for _, actor := range selectedActors {
		assert.Equal(t, newFirstNames[0], actor.FirstName)
		assert.NotEqual(t, actor.FirstName, newFirstNames[1])
	}

	// Question: How would the update query here have known which EDs and which JENNIFERSs
	// should be updated with which names from updatedFirstNames?

	// Note: The SQL generated by this go-pg query is using a list of strings
	// in the WHERE clause. We need the WHERE clause to specify that it is looking at the
	// first_name field from the _data table to create a mapping between the rows and
	// the update values.

	// Correct Approach: Add the primary keys to the `actors` objects and use `WherePK()`.
}

func Test_UpdateMultipleRowsByNonPrimaryKey_Solution(t *testing.T) {
	db := dal.Connect()
	defer db.Close()

	///////////////////////////////////////////////////////////////////
	// 1. Retrieve the rows you want to update from the DB with the PK
	// (or get the PK some other way into the slice)

	testRowIds := []int{3, 4, 136, 179}
	var actors []models.Actor
	err := db.Model(&actors).
		Column("actor_id").
		WhereIn("actor_id IN (?)", testRowIds).
		Select()
	assert.NoError(t, err)

	// Assertions
	// ...the correct number of rows were retrieved...
	assert.Equal(t, len(testRowIds), len(actors))
	// ...and they contain only the Primary Key...
	for _, actor := range actors {
		assert.NotEmpty(t, actor.ActorId)
		assert.Empty(t, actor.FirstName)
		assert.Empty(t, actor.LastUpdate)
	}

	/////////////////////////////////////////////////////////////////////////
	// 2. Add the values you want updated to the slice and perform the update

	newFirstNames := []string{"ANNA", "JOE", "PRINCE", "RALF"}
	for i := range actors {
		actors[i].FirstName = newFirstNames[i]
	}

	_, err = db.Model(&actors).
		Column("first_name").
		WherePK().
		Returning("*").
		Update()
	if err != nil {
		fmt.Println(err)
	}

	// Assertions
	// ...get the latest data from the db
	var selectedActors []models.Actor
	err = db.Model(&selectedActors).WhereIn("actor_id IN (?)", testRowIds).Select()
	assert.NoError(t, err)

	// ...check that the correct number of rows were updated...
	assert.Equal(t, len(testRowIds), len(selectedActors))
	// ...and that the correct row now has the (correct) newly updated first_name
	for i, actor := range selectedActors {
		assert.Equal(t, testRowIds[i], actor.ActorId)
		assert.Equal(t, newFirstNames[i], actor.FirstName)
	}
}
