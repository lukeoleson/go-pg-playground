package v9examples

import (
	"fmt"
	"testing"

	"github.com/go-pg/pg/v9"

	"github.com/lukeoleson/go-pg-playground/data/dal"
	"github.com/stretchr/testify/assert"

	"github.com/lukeoleson/go-pg-playground/data/models"
)

func Test_UpdateMultipleRowsWithDifferentValuesPerRow_Problem(t *testing.T) {
	db := dal.ConnectV9()
	defer db.Close()

	///////////////////////////////////////////////////////////////////
	// 1. Get some rows to update

	testRowIds := []int{41, 42}
	var actors []models.Actor
	err := db.Model(&actors).
		Column("first_name", "last_name").
		WhereIn("actor_id IN (?)", testRowIds).
		Select()
	assert.NoError(t, err)

	/////////////////////////////////////////////////////////////////////////
	// 2. Modify the values you want updated in the slice

	newFirstNames := []string{"ANNA", "JOE"}
	for i := range actors {
		actors[i].FirstName = newFirstNames[i]
	}

	/////////////////////////////////////////////////////////////////////////
	// 3. Perform the update

	// NOTE: The query generated by this function call uses a list of values in the
	// where clause. This seems to be what causes the update to use the same values for
	// every row - e.g. `WHERE (a.actor_id IN (41, 42)`.
	res, err := db.Model(&actors).
		Column("first_name").
		Where("a.actor_id IN (?)", pg.In(testRowIds)).
		Returning("*").
		Update()
	if err != nil {
		fmt.Println(err)
	}

	// Assertions
	assert.Equal(t, len(testRowIds), res.RowsAffected())

	// ...get the latest data from the db
	var selectedActors []models.Actor
	err = db.Model(&selectedActors).WhereIn("actor_id IN (?)", testRowIds).Select()
	assert.NoError(t, err)

	// NOTE: The `first_name` of each row was updated to the `FirstName` from the first
	// element in `actors`.
	assert.Equal(t, len(testRowIds), len(selectedActors))
	for i, actor := range selectedActors {
		assert.Equal(t, testRowIds[i], actor.ActorId)
		assert.Equal(t, newFirstNames[0], actor.FirstName)
	}
}

func Test_UpdateMultipleRowsWithDifferentValuesPerRow_Solution(t *testing.T) {
	db := dal.ConnectV9()
	defer db.Close()

	///////////////////////////////////////////////////////////////////
	// 1. Get some rows to update

	testRowIds := []int{22, 23}
	var actors []models.Actor
	err := db.Model(&actors).
		Column("first_name", "last_name").
		WhereIn("actor_id IN (?)", testRowIds).
		Select()
	assert.NoError(t, err)

	/////////////////////////////////////////////////////////////////////////
	// 2. Modify the values you want updated in the slice

	newFirstNames := []string{"ANNA", "JOE"}
	for i := range actors {
		actors[i].FirstName = newFirstNames[i]
	}

	/////////////////////////////////////////////////////////////////////////
	// 3. Perform the update

	// convert our rows to a slice of interfaces so we can use the variadic
	// operator to feed all the rows into our models method in the query
	b := make([]interface{}, len(actors))
	for i := range actors {
		b[i] = actors[i]
	}

	// NOTE 1: Hardcoding the WHERE clause here allows us to get the WHERE clause
	// that we want, which reads from the `_data` table rather than just a list of
	// values - e.g. `WHERE actor_id IN (_data.actor_id)`
	//
	// NOTE 2: Adding a `.Returning("*")` throws an error as it will try to scan the id
	// field, which is un-settable (doesn't make much sense, but it happens!)
	_, err = db.Model(b...).
		Column("first_name").
		Where("a.actor_id IN (_data.actor_id)").
		Update()
	if err != nil {
		fmt.Println(err)
	}

	/////////////////////////////////////////////////////////////////////////
	// 4. Make some assertions

	// ...get the latest data from the db
	var selectedActors []models.Actor
	err = db.Model(&selectedActors).WhereIn("actor_id IN (?)", testRowIds).Select()
	assert.NoError(t, err)

	// ...check that the correct number of rows were updated...
	assert.Equal(t, len(testRowIds), len(selectedActors))

	// ...and that the correct row now has the (correct) newly updated first_name
	for i, actor := range selectedActors {
		assert.Equal(t, testRowIds[i], actor.ActorId)
		assert.Equal(t, newFirstNames[i], actor.FirstName)
	}
}
